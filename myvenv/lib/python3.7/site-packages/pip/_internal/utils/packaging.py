from __future__ import absolute_import

import logging
<<<<<<< HEAD
=======
import sys
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
from email.parser import FeedParser

from pip._vendor import pkg_resources
from pip._vendor.packaging import specifiers, version

<<<<<<< HEAD
from pip._internal.exceptions import NoneMetadataError
=======
from pip._internal import exceptions
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
from pip._internal.utils.misc import display_path
from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
<<<<<<< HEAD
    from typing import Optional, Tuple
    from email.message import Message
    from pip._vendor.pkg_resources import Distribution
=======
    from typing import Optional  # noqa: F401
    from email.message import Message  # noqa: F401
    from pip._vendor.pkg_resources import Distribution  # noqa: F401
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e


logger = logging.getLogger(__name__)


<<<<<<< HEAD
def check_requires_python(requires_python, version_info):
    # type: (Optional[str], Tuple[int, ...]) -> bool
    """
    Check if the given Python version matches a "Requires-Python" specifier.

    :param version_info: A 3-tuple of ints representing a Python
        major-minor-micro version to check (e.g. `sys.version_info[:3]`).

    :return: `True` if the given Python version satisfies the requirement.
        Otherwise, return `False`.

    :raises InvalidSpecifier: If `requires_python` has an invalid format.
=======
def check_requires_python(requires_python):
    # type: (Optional[str]) -> bool
    """
    Check if the python version in use match the `requires_python` specifier.

    Returns `True` if the version of python in use matches the requirement.
    Returns `False` if the version of python in use does not matches the
    requirement.

    Raises an InvalidSpecifier if `requires_python` have an invalid format.
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
    """
    if requires_python is None:
        # The package provides no information
        return True
    requires_python_specifier = specifiers.SpecifierSet(requires_python)

<<<<<<< HEAD
    python_version = version.parse('.'.join(map(str, version_info)))
=======
    # We only use major.minor.micro
    python_version = version.parse('.'.join(map(str, sys.version_info[:3])))
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
    return python_version in requires_python_specifier


def get_metadata(dist):
    # type: (Distribution) -> Message
<<<<<<< HEAD
    """
    :raises NoneMetadataError: if the distribution reports `has_metadata()`
        True but `get_metadata()` returns None.
    """
    metadata_name = 'METADATA'
    if (isinstance(dist, pkg_resources.DistInfoDistribution) and
            dist.has_metadata(metadata_name)):
        metadata = dist.get_metadata(metadata_name)
    elif dist.has_metadata('PKG-INFO'):
        metadata_name = 'PKG-INFO'
        metadata = dist.get_metadata(metadata_name)
=======
    if (isinstance(dist, pkg_resources.DistInfoDistribution) and
            dist.has_metadata('METADATA')):
        metadata = dist.get_metadata('METADATA')
    elif dist.has_metadata('PKG-INFO'):
        metadata = dist.get_metadata('PKG-INFO')
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
    else:
        logger.warning("No metadata found in %s", display_path(dist.location))
        metadata = ''

<<<<<<< HEAD
    if metadata is None:
        raise NoneMetadataError(dist, metadata_name)

    feed_parser = FeedParser()
    # The following line errors out if with a "NoneType" TypeError if
    # passed metadata=None.
=======
    feed_parser = FeedParser()
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e
    feed_parser.feed(metadata)
    return feed_parser.close()


<<<<<<< HEAD
def get_requires_python(dist):
    # type: (pkg_resources.Distribution) -> Optional[str]
    """
    Return the "Requires-Python" metadata for a distribution, or None
    if not present.
    """
    pkg_info_dict = get_metadata(dist)
    requires_python = pkg_info_dict.get('Requires-Python')

    if requires_python is not None:
        # Convert to a str to satisfy the type checker, since requires_python
        # can be a Header object.
        requires_python = str(requires_python)

    return requires_python
=======
def check_dist_requires_python(dist):
    pkg_info_dict = get_metadata(dist)
    requires_python = pkg_info_dict.get('Requires-Python')
    try:
        if not check_requires_python(requires_python):
            raise exceptions.UnsupportedPythonVersion(
                "%s requires Python '%s' but the running Python is %s" % (
                    dist.project_name,
                    requires_python,
                    '.'.join(map(str, sys.version_info[:3])),)
            )
    except specifiers.InvalidSpecifier as e:
        logger.warning(
            "Package %s has an invalid Requires-Python entry %s - %s",
            dist.project_name, requires_python, e,
        )
        return
>>>>>>> 71358189c5e72ee2ac9883b408a2f540a7f5745e


def get_installer(dist):
    # type: (Distribution) -> str
    if dist.has_metadata('INSTALLER'):
        for line in dist.get_metadata_lines('INSTALLER'):
            if line.strip():
                return line.strip()
    return ''
